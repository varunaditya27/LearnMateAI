/**
 * Leaderboard API Route
 * GET /api/leaderboard
 * 
 * Get leaderboard rankings with filtering options.
 */

import { NextRequest, NextResponse } from 'next/server';
import { verifyAuth } from '@/lib/auth-middleware';
import { db } from '@/lib/firebase';
import { collection, query, orderBy, limit, where, getDocs, Timestamp } from 'firebase/firestore';

interface UserStatsDoc {
  displayName?: string;
  photoURL?: string | null;
  badge?: string | null;
  updatedAt?: Timestamp;
  stats?: {
    totalPoints?: number;
    currentStreak?: number;
    level?: number;
  };
}

export async function GET(request: NextRequest) {
  // NOTE: If timeframe filtering triggers missing index errors (failed-precondition), we fall back to all-time.
  // Recommended composite index for timeframe queries (users collection):
  //   fields: [ { fieldPath: "updatedAt", order: "DESCENDING" }, { fieldPath: "stats.totalPoints", order: "DESCENDING" } ]
  // URL (generated by Firestore):
  //   https://console.firebase.google.com/v1/r/YOUR_PROJECT/firestore/indexes?create_composite=... (see runtime log for exact link)
  try {
    // Optional auth (kept in case of future personalization)
    await verifyAuth(request);
    const { searchParams } = new URL(request.url);
    const timeframe = searchParams.get('timeframe') || 'all-time'; // 'weekly', 'monthly', 'all-time'
    const limitCount = Math.min(parseInt(searchParams.get('limit') || '10', 10), 100);

    const usersRef = collection(db, 'users');
    let effectiveTimeframe = timeframe;
    let q = query(usersRef, orderBy('stats.totalPoints', 'desc'), limit(limitCount));

    const needsFiltered = timeframe === 'weekly' || timeframe === 'monthly';
    if (needsFiltered) {
      const dateAgo = new Date();
      if (timeframe === 'weekly') dateAgo.setDate(dateAgo.getDate() - 7);
      if (timeframe === 'monthly') dateAgo.setMonth(dateAgo.getMonth() - 1);
      try {
        q = query(
          usersRef,
          where('updatedAt', '>=', Timestamp.fromDate(dateAgo)),
          orderBy('stats.totalPoints', 'desc'),
          limit(limitCount)
        );
      } catch {
        // Construction errors unlikely; fallback handled in fetch below
      }
    }

    let querySnapshot;
    try {
      querySnapshot = await getDocs(q);
    } catch (err: unknown) {
      // Detect missing index; fallback to all-time
      if (typeof err === 'object' && err !== null && 'code' in err && (err as { code?: string }).code === 'failed-precondition') {
        const message = 'message' in err ? (err as { message?: string }).message : undefined;
        console.warn('[leaderboard] Missing index for timeframe query. Falling back to all-time. Error:', message);
        effectiveTimeframe = 'all-time';
        const fallbackQuery = query(usersRef, orderBy('stats.totalPoints', 'desc'), limit(limitCount));
        querySnapshot = await getDocs(fallbackQuery);
      } else {
        throw err;
      }
    }

    const leaderboard = querySnapshot.docs.map((doc, index) => {
      const data = doc.data() as UserStatsDoc;
      return {
        userId: doc.id,
        displayName: data.displayName || 'Anonymous',
        photoURL: data.photoURL || null,
        points: data?.stats?.totalPoints ?? 0,
        streak: data?.stats?.currentStreak ?? 0,
        rank: index + 1,
        level: data?.stats?.level ?? 1,
        badge: data.badge || null,
      };
    });

    return NextResponse.json({
      success: true,
      data: leaderboard,
      meta: {
        timeframe: effectiveTimeframe,
        total: leaderboard.length,
        downgraded: effectiveTimeframe !== timeframe,
      },
    });
  } catch (error) {
    console.error('Get leaderboard error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to get leaderboard' },
      { status: 500 }
    );
  }
}
